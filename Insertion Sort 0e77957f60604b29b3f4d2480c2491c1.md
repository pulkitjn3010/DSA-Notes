# Insertion Sort
---
***Insertion sort sorts an array by going through each element and placing it into its correct position among the already sorted elements.***
---

## Algorithm

1. Select an element in each iteration from the unsorted array(using an outer loop).
2. Insert it into its correct position among the already sorted elements (using an inner loop and swapping).
3. Repeat for all elements.

### What the outer loop (i) is doing?

Iterates from the first unsorted element (index 1) to the last element in the array.

| i | Pass  | Sort Array till Index | [5  3  4  1  2] |
| --- | --- | --- | --- |
| 0 | 1 | 1 | 3  5  4  1  2 |
| 1 | 2 | 2 | 3  4  5  1  2 |
| 2 | 3 | 3 | 1  3  4  5  2 |
| 3 | 4 | 4 | 1  2  3  4  5  |

⇒ after i = 3 (n-2) array gets sorted completely

⇒ i is running from [0, n-2]. As when i becomes 3(n-2) j becomes 4(n-1). If i were 4(n-1) then j becomes 5(n) which on calculating arr[j] i.e. arr[5] will throw index out of bound exception

### What the inner loop (j) is doing?

1. Compares the current element `arr[j]` with the elements before it, moving leftwards.
2. **Comparison and Swap**: If `arr[j]` is smaller than `arr[j - 1]`, they are swapped using the `swap` method. If not, the inner loop breaks because the elements before `arr[j]` are already sorted.

| i | Pass  | Sort Array till Index | j = i+1 to j > 0 | arr[j] < arr[j-1] true → swap false → break | arr = [5  3  4  1  2] |
| --- | --- | --- | --- | --- | --- |
| 0 | 1 | 1 | 1 | true → swap | 5  3  4  1  2 |
|  |  |  |  |  | 3  5  4  1  2 |
| 1 | 2 | 2 | 2 | true → swap | 3  5  4  1  2 |
|  |  |  | 1 | false → break | 3  4  5  1  2 |
|  |  |  |  |  | 3  4  5  1  2 |
| 2 | 3 | 3 | 3 | true → swap | 3  4  5  1  2 |
|  |  |  | 2 | true → swap | 3  4  1  5  2 |
|  |  |  | 1 | true → swap | 3  1  4  5  2 |
|  |  |  |  |  | 1  3  4  5  2 |
| 3 | 4 | 4 | 4 | true → swap | 1  3  4  5  2 |
|  |  |  | 3 | true → swap | 1  3  4  2  5 |
|  |  |  | 2 | true → swap | 1  3  2  4  5 |
|  |  |  | 1 | false → break | 1  2  3  4  5 |
|  |  |  |  |  | 1  2  3  4  5  |

***Why we break the loop when the condition becomes false?***

If condition become false than this means that the LHS is already sorted and the element is at the correct index. There is no need to check further till the first element it’s just additional steps.

---

## Code

```java
// Method to perform insertion sort on the array
static void insertionSort(int[] arr) {
    int n = arr.length;
    // Start from the second element (index = 1) and go to the end of the array
    for (int i = 0; i <= n - 2; i++) {
        // For each element, compare it with the elements before it
        for (int j = i + 1; j > 0; j--) {
            // If the current element is smaller than the previous one, swap them
            if (arr[j] < arr[j - 1]) {
                swap(arr, j, j - 1);
            } else {
                // If no swap is needed, exit the inner loop
                break;
            }
        }
    }
}

// Method to swap two elements in the array
static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

---

## Time complexity

- **Worst Case**: O(N²) — when the array is in reverse order.
- **Average Case**: O(N²) — for random order arrays.
- **Best Case**: O(N) — when the array is already sorted.
1. **Worst Case Time Complexity: O(N²)**
    - **Reason**: In the worst case, the array is sorted in reverse order. The outer loop runs `N` times, and for each iteration, the inner loop can run up to `i` times, where `i` ranges from 1 to `N-1`. The total number of comparisons and shifts is the sum of the first `N-1` integers, which is approximately `(N*(N-1))/2`. Ignoring constant factors and lower-order terms, this results in a time complexity of `O(N²)`.
2. **Average Case Time Complexity: O(N²)**
    - **Reason**: On average, the inner loop will perform a number of operations proportional to the size of the sorted portion. Over all possible input permutations, the average number of shifts and comparisons remains quadratic. Thus, the average case complexity is also `O(N²)`.
3. **Best Case Time Complexity: O(N)**
    - **Reason**: The best case occurs when the array is already sorted. In this scenario, the outer loop still runs `N-1` times, but the inner loop does not perform any shifts or comparisons because all elements are already in place. Each iteration of the inner loop runs in constant time `O(1)`, resulting in an overall linear time complexity of `O(N)`.

---

## Space Complexity

O(1)

---

## Why Insertion Sort?

1. **Adaptive**: Steps gets reduced if array is sorted. [Number of swaps are reduced as compared to Bubble Sort]
2. **Stable Sorting Algorithm**
3. **Used for smaller values of n**: Works good if array is partially sorted.[Can be a part of hybrid sorting algorithm]

---
